Inject Refactoring to JavaScript Proposal

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~ The Flow                                                                 ~~~
~~~ This is the flow through our external APIs. It helps ensure we're not    ~~~
~~~ missing any important steps                                              ~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
require.ensure([modules], callback)
-----------------------------------
  Inject: strip all modules we have loaded
  Inject: strip all modules that are builtins
  Inject: keep a count of remaining modules, for each module we need...
    DownloadManager.download(moduleId, cb) // cb count--, on count 0 continue

    DownloadManager.download
    ------------------------
    DownloadManager: Create a top level Tree Node

    DownloadManager: Pass through to DownloadManagaer.downloadTree(tree, cb)

      DownloadManagaer.downloadTree
      -----------------------------
      DownloadManager: Transform moduleId into Url
        RulesEngine.applyRules(moduleId)
        Communicator.get(url, callback) // cb invokes analysis and recursion

      DownloadManager: Analyze file
        Analyzer.extractRequires(file)

      DownloadManager: for each require, add a tree node, then downloadTree

  Inject: for all the trees returned, get their postOrder, for each module...
    Executor.runModule(moduleId)
  Inject: all modules have executed, invoke callback() with correct arg order


__internal__ = blocks of logic that exist in inject.coffee
__external__ = published methods
__wiring__ = any notes about dependencies

################################################################################
### INJECT LAYER                                                             ###
### Main Inject entry point. Keep this somewhat lightweight, as its purpose  ###
### is to expose the public API                                              ###
################################################################################

Inject (static)
  __internal__
  __external__
    require(id or [ids], callback or null)
    require.ensure([ids], callback)
    require.run(id)
    require.toUrl(id)
    define(id or dependencies, dependencies or callback, callback or null)
      note: define is overloaded to provide the following calls
        1. define(id, dependencies, callback)
        2. define(dependencies, callback) (id implied by file queue)
        3. define(callback) (id implied by file queue)
    define.amd = true
    setModuleRoot(root)
    setCrossDomain({obj})
      note: the config object evolved in 0.4.0 to provide the following options
        relayFile: the relay.html location for easyXDM
        relaySwf: the relay.swf location for easyXDM
    clearCache()
    setExpires(seconds)
    reset()
    clearFileRegistry()
    addRule(regexMatch, weight = 0, {rulesetObject} or pathReplace)
      note: passthrough to RulesEngine
    manifest({object})
      note: passthrough to RulesEngine
  __wiring__
    window.Inject = new Inject(this or window);
      note: instantiate into window.Inject as singleton

################################################################################
### DATABASE LAYER - jakob                                                   ###
### Provide access to our Module DB (db{} in inject.coffee), all the queues, ###
### etc within a much more familliar interface. Reduce the maintenance cost  ###
### of method changes                                                        ###
### Using the DataBase from another layer:                                   ###
### var DB = DataBase; // calling new DataBase() is the same                 ###
### var moduleDB = DB.create("modules", "moduleDB");                         ###
### moduleDB.byId(moduleId).set("key", "value");                             ###
################################################################################

DONE

################################################################################
### ANALYZER STATIC LAYER - jakob                                            ###
### Group our analysis functions together                                    ###
################################################################################

DONE

################################################################################
### RULES ENGINE LAYER                                                       ###
### Collapse all the addRule applyRules logic                                ###
################################################################################

DONE

################################################################################
### DOWNLOAD MANAGER                                                         ###
### Takes care of downloading a top level file, followed by all its          ###
### dependencies, ultimately calling the callback once the entire tree has   ###
### been retrieved                                                           ###
################################################################################

DownloadManager
  __internal__
    downloadTree(treeNode, callback)
      note: uses communicator.get() to get the file, then it will call
            analyzer.extractRequires() to get the requires. It probably needs
            an internal cache of everything it's seen this Tree run to prevent
            circular loops
            Results are stored in the module DB
  __external__
    download(moduleId, callback)
      note: this needs to transform a moduleId to a URL for Communicator,
      the callback needs the tree of all files it downloaded

################################################################################
### TREE NODE - jakob                                                        ###
### This is the tree object we use for mapping dependencies, once an         ###
### internal class, now a first class citizen                                ###
################################################################################

DONE

################################################################################
### COMMUNICATOR                                                             ###
### This smashes together our two different XHR items behind a standardized  ###
### interface. Nobody knows the framework is "paused" except this guy        ###
################################################################################

DONE (simple tests)

################################################################################
### EXECUTOR                                                                 ###
### Able to run JavaScript as an eval()-ish, or run a module by its ID which ###
### requires pulling the file out of the databases                           ###
################################################################################

DONE

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

COMPLETED MODULES
Tests and all!

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

DataBase (static + factory)
  __internal__
  __external__
    create(name, type)
      note: if a DB of "name" already exists, return that instead
    getInstance()
      note: standard singleton interface
    register(type, {obj})
      note: this is how other DB types will register into the system

GenericDB
  note: this is to be extended for other DB types. Record objects (contained)
  make it easy to refactor get/set interfaces
  __internal__
  __external__
    insert(id, record)
    reset()
    byId(id)
      note: returns the Record Object @ that ID

GenericDBRecord
  __internal__
  __external__
    defineAs({obj})
      note: force the record to contain the provided fields
    get(name, raw=false)
      note: if this["get_"+name] exists and !raw, return that instead
        interface: return this["get_"+name](originalValue)
    set(name, value, raw=false)
      note: if this["set_"+name] exists and !raw, return that instead
        interface: return this["set_"+name](value)

ModuleDB
  note: this is the major workhorse... and is some obscene amount of our
  filesize
  __internal__
  __external__
    insert(id, record)
      note: overload, use ModuleDBRecord

ModuleDBRecord
  note: here is where we hook in lscache
  __internal__
  __external__
    get_exports(exports)
    get_file(file)
    set_file(file)

TransactionDB
  note: this replaces db.txn
  __internal__
  __external__
    insert(id, record)
      note: overload, use TransactionDBRecord

TransactionDBRecord
  __internal__
  __external__
    add()
    subtract()

QueueDB
  __internal__
  __external__
    insert(id, record)
      note: overload, use QueueDBRecord

QueueDBRecord
  __internal__
  __external__
    add(item)
    empty()
    peek()
    remove()
    sort(sortFunction)
    size()

Analyzer (static)
  __internal__
  __external__
    extractRequires(file)
    getFunctionArgs(function or string)
    
TreeNode
  note: this is pretty much as-is. DownloadManager owns the instantiation of
  the tree, so this is a local point for inclusion

RulesEngine (static)
  __internal__
  __external__
    getPointcuts(moduleId, asString = true)
    addRule(regexMatch, weight = 0, {rulesetObject} or pathReplace)
    manifest({object})
    resolve(moduleId)

Executor (static)
  __internal__
    all the eval script / module / error work we've done
  __external__
    runModule(moduleId)

Communicator (static)
  __internal__
    all the createIframe stuff
  __external__
    get(url, callback)